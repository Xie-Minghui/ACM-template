#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
#define per(i,a,b) for(int i = a;i <= b;++i)
#define rep(i,a,b) for(int i = a;i >= b;--i)
const int maxn = 3e5;
int n = 0,k = 0;
int a[maxn+10];
LL suf[maxn+10];
/*
本题的思维启示：首先，他是连续区间，意味着区间每个数的位置不能改变。
所以首先想到贪心从开始选取，但是如果从1-n开始贪心，贪心前面的不知道会对后面造成什么影响，还有k这个约束。
之前的思维是既然无法对每个数直接通过改变他们顺序贪心，那么久从1-n开始贪心，一步一步划分，将划分出来的新部分
*他的权重。  总的来说就是，先确定分法，然后再计算权重。
这是比较直观的思维，这道题不要求方案，所以我们可以直接求结果，然后通过结果推知方案。
之前是将每个部分分开看分开计算的，那么对于这种权重（且是连续的）可以通过各个部分重叠模拟。重叠K次的部分就是
最后一部分的划分办法，一次推知前面的分法。因为后面的权重大，所以计算后缀（后缀重复），这可以保证后面被分配，
但是最前面的分配要靠suf[1]，保证前面被分配。然后再剩下的后缀中选取最大的前k-1个即可。
启发：求解问题不一定要先求出分法，然后计算结果，直接思维,或者是问题的定义。
我们可以转换思维角度，不被定义所困，可以通过其他方式等价模拟出分法，而且可以先求出结果，然后根据结果确定分法。
*/
void solve(){
	LL ans = suf[1];//保证前面的所有数都被分配
	sort(suf+2,suf+1+n);
 	rep(i,n,n-k+1+1){//选择后缀和最大的前k-1个
		ans += suf[i];
	}
	printf("%I64d\n",ans);
}
int main(){
	while(~scanf("%d %d",&n,&k)){
		memset(suf,0,sizeof(suf));
		per(i,1,n){
			scanf("%d",&a[i]);
		}
		rep(i,n,1){//记录后缀和
			suf[i] = suf[i+1] + a[i];
		}
		solve();
	}
		
	return 0;
}
